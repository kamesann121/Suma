<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新しいタブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #dcdcdc; font-family: sans-serif; }
        #gui-overlay { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.7); padding: 25px; border-radius: 12px;
            text-align: center; pointer-events: none; z-index: 200; font-weight: bold;
        }
        #ui-bar { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 300; }
        .item-slot {
            width: 60px; height: 60px; background: rgba(0, 0, 0, 0.6); border: 2px solid #555; border-radius: 8px;
            display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;
        }
        .item-slot.selected { border-color: #ffaa00; background: rgba(255, 170, 0, 0.4); }
        #aim-mark {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 8px; height: 8px; border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%; pointer-events: none; z-index: 100;
        }
    </style>
</head>
<body>
    <div id="gui-overlay">START APPLICATION<br>(Keys 1, 2, 3 / V: Squat)</div>
    <div id="aim-mark"></div>
    <div id="ui-bar">
        <div class="item-slot selected" id="s-1">Mode 1</div>
        <div class="item-slot" id="s-2">Mode 2</div>
        <div class="item-slot" id="s-3">Special</div>
    </div>

    <script>
        let scene, camera, renderer, clock, mainMixer, coreModel;
        let effectMixer;
        let keys = { q: false, e: false, c: false, s: false };
        let vertVel = 0, inAir = false, jumpReady = true, isLowPos = false, procActive = false;
        let activeIdx = 1, motionLib = {}, activeMotion;
        let r_mount, l_mount, subAsset;
        let baseVfx, handVfx, projectiles = [], camRotX = 0, camRotY = 0.2;
        let isStandby = false;
        const gltfLoader = new THREE.GLTFLoader();

        function switchMotion(id, gap = 0.2) {
            const target = motionLib[id];
            if (target && activeMotion !== target) {
                if (activeMotion) activeMotion.fadeOut(gap);
                target.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(gap).play();
                activeMotion = target;
            }
        }

        async function updateMode(idx) {
            if (activeIdx === idx || procActive) return;
            if (activeIdx === 3) {
                isStandby = false;
                if (baseVfx) baseVfx.visible = false;
                if (handVfx) handVfx.visible = false;
                switchMotion('m_end', 0.2);
                await new Promise(r => setTimeout(r, 400));
            }
            activeIdx = idx;
            document.querySelectorAll('.item-slot').forEach((s, i) => s.classList.toggle('selected', i === idx - 1));
            if (subAsset) subAsset.visible = (idx === 2);
            if (idx === 3) {
                isStandby = true;
                switchMotion('m_start', 0.2);
                if (baseVfx) {
                    baseVfx.visible = true;
                    baseVfx.position.y = -1.0;
                    if (effectMixer) effectMixer.clipAction(baseVfx.animations[0]).reset().play();
                }
                if (handVfx) {
                    handVfx.visible = true;
                    // --- 修正：サイズを前回の3倍(0.11)に大きく設定 ---
                    handVfx.scale.set(0.11, 0.11, 0.11); 
                }
                setTimeout(() => { if (activeIdx === 3) isStandby = false; }, 5000);
            } else {
                refreshMove();
            }
        }

        function emitObj() {
            if (!l_mount) return;
            const pos = new THREE.Vector3();
            l_mount.getWorldPosition(pos);
            gltfLoader.load('./magicball.glb', (data) => {
                const obj = data.scene;
                obj.position.copy(pos);
                // モデル本来の見た目を活かす
                const vec = new THREE.Vector3(0, 0, 1).applyQuaternion(coreModel.quaternion);
                scene.add(obj);
                projectiles.push({ mesh: obj, v: vec, ttl: 100 });
            });
        }

        function triggerAction() {
            if (procActive || inAir || isStandby) return;
            procActive = true;
            let mId = (activeIdx === 2) ? 'm_action2' : (activeIdx === 3 ? 'm_action3' : 'm_action1');
            if (activeIdx === 3) emitObj();
            switchMotion(mId, 0.1);
            setTimeout(() => { procActive = false; refreshMove(); }, 800);
        }

        function refreshMove() {
            if (procActive || inAir || (activeIdx === 3)) return;
            let dx = (keys.q ? -1 : 0) + (keys.c ? 1 : 0);
            let dz = (keys.e ? -1 : 0) + (keys.s ? 1 : 0);
            if (dx !== 0 || dz !== 0) {
                if (isLowPos) switchMotion('m_low_walk', 0.2);
                else if (keys.e && !keys.s && !keys.q && !keys.c) switchMotion('m_fast', 0.2);
                else switchMotion('m_walk', 0.2);
            } else {
                if (activeIdx === 2) switchMotion('m_idle2', 0.2);
                else switchMotion(isLowPos ? 'm_low_idle' : 'm_idle1', 0.2);
            }
        }

        window.onload = function() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.5));
            scene.add(new THREE.GridHelper(500, 100, 0x999999, 0xcccccc));

            document.body.addEventListener('mousedown', (e) => {
                if(document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                    document.getElementById('gui-overlay').style.display = 'none';
                } else if (e.button === 0) triggerAction();
            });

            gltfLoader.load('./magic.glb', (d) => { 
                baseVfx = d.scene; baseVfx.visible = false; baseVfx.animations = d.animations;
                effectMixer = new THREE.AnimationMixer(baseVfx); scene.add(baseVfx); 
            });
            gltfLoader.load('./magic2.glb', (d) => { handVfx = d.scene; handVfx.visible = false; scene.add(handVfx); });

            gltfLoader.load('./m.glb', (d) => {
                coreModel = d.scene; scene.add(coreModel);
                mainMixer = new THREE.AnimationMixer(coreModel);
                coreModel.traverse(n => {
                    if(n.isBone) {
                        const nm = n.name.toLowerCase();
                        if(nm.includes("hand") && nm.includes("l")) l_mount = n;
                        if(nm.includes("hand") && nm.includes("r")) r_mount = n;
                    }
                });

                gltfLoader.load('./sword.glb', (sd) => {
                    subAsset = sd.scene; subAsset.visible = false;
                    if(r_mount) { r_mount.add(subAsset); subAsset.rotation.set(Math.PI/2, 0, Math.PI); }
                });

                ['./a.glb', './b.glb'].forEach(u => {
                    gltfLoader.load(u, (ad) => {
                        ad.animations.forEach((clip, i) => {
                            clip.tracks = clip.tracks.filter(t => !t.name.endsWith('.position'));
                            const act = mainMixer.clipAction(clip);
                            if (clip.name === 'Idle_Loop') motionLib['m_idle1'] = act;
                            if (clip.name === 'Walk_Loop') motionLib['m_walk'] = act;
                            if (clip.name === 'Sprint_Loop') motionLib['m_fast'] = act;
                            if (clip.name === 'Jump_Start') { motionLib['m_j_s'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            if (clip.name === 'Jump_Loop') motionLib['m_j_l'] = act;
                            if (clip.name === 'Jump_Land') { motionLib['m_j_e'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            if (u === './b.glb') {
                                if (i === 1) motionLib['m_low_walk'] = act;
                                if (i === 2) motionLib['m_low_idle'] = act;
                                if (i === 25) { motionLib['m_action1'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 42) motionLib['m_idle2'] = act;
                                if (i === 40) { motionLib['m_action2'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 33) { motionLib['m_start'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 35) motionLib['m_pose'] = act;
                                if (i === 36) { motionLib['m_action3'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 34) { motionLib['m_end'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            }
                        });
                        if (motionLib['m_idle1']) switchMotion('m_idle1');
                    });
                });
            });

            window.onkeydown = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) keys[k] = true;
                if (k === 'v') isLowPos = !isLowPos;
                // 魔法装備時はジャンプ不可
                if (k === ' ' && !inAir && jumpReady && activeIdx !== 3) { 
                    inAir = true; jumpReady = false; vertVel = 0.18; switchMotion('m_j_s', 0.1); 
                }
                if (['1','2','3'].includes(k)) updateMode(parseInt(k));
            };
            window.onkeyup = (e) => { if (['e','s','q','c'].includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; };
            window.addEventListener('mousemove', (e) => { 
                if (document.pointerLockElement === document.body) { 
                    camRotX -= e.movementX * 0.002; 
                    camRotY = Math.max(-0.7, Math.min(1.1, camRotY + e.movementY * 0.002)); 
                } 
            });

            clock = new THREE.Clock();
            function run() {
                requestAnimationFrame(run);
                const dt = clock.getDelta();
                if (mainMixer) mainMixer.update(dt);
                if (effectMixer) effectMixer.update(dt);

                if (coreModel) {
                    const activeMove = !procActive && activeIdx !== 3;
                    let dx = (keys.q ? -1 : 0) + (keys.c ? 1 : 0);
                    let dz = (keys.e ? -1 : 0) + (keys.s ? 1 : 0);
                    if (activeMove && (dx !== 0 || dz !== 0)) {
                        const targetRot = Math.atan2(dx, dz) + camRotX;
                        let diff = targetRot - coreModel.rotation.y;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        coreModel.rotation.y += diff * 0.15;
                        const s = (keys.e && !keys.s && !keys.q && !keys.c && !isLowPos) ? 0.14 : 0.07;
                        coreModel.position.x += Math.sin(coreModel.rotation.y) * s;
                        coreModel.position.z += Math.cos(coreModel.rotation.y) * s;
                    }
                    refreshMove();

                    if (baseVfx && baseVfx.visible) {
                        baseVfx.position.set(coreModel.position.x, baseVfx.position.y, coreModel.position.z);
                        if (baseVfx.position.y < 0) baseVfx.position.y += 0.01;
                        baseVfx.rotation.y += 0.02;
                    }
                    if (handVfx && handVfx.visible && l_mount) {
                        const p = new THREE.Vector3(); l_mount.getWorldPosition(p);
                        handVfx.position.copy(p);
                        // 逆回転
                        handVfx.rotation.x -= 0.05; handVfx.rotation.y -= 0.05;
                    }
                    for (let i = projectiles.length - 1; i >= 0; i--) {
                        projectiles[i].mesh.position.add(projectiles[i].v.clone().multiplyScalar(0.4));
                        if (projectiles[i].ttl-- <= 0) { scene.remove(projectiles[i].mesh); projectiles.splice(i, 1); }
                    }

                    if (inAir) {
                        coreModel.position.y += vertVel; vertVel -= 0.008;
                        if (vertVel < 0 && activeMotion === motionLib['m_j_s']) switchMotion('m_j_l', 0.3);
                        if (coreModel.position.y <= 0) { 
                            coreModel.position.y = 0; inAir = false; switchMotion('m_j_e', 0.1);
                            setTimeout(() => { jumpReady = true; refreshMove(); }, 300);
                        }
                    } else {
                        const ty = (isLowPos && activeIdx !== 3) ? -0.4 : 0;
                        coreModel.position.y += (ty - coreModel.position.y) * 0.1;
                    }

                    const d = 2.4, sh = 1.0, h = 1.5;
                    const hd = d * Math.cos(camRotY), vd = d * Math.sin(camRotY);
                    let cx = coreModel.position.x + hd * Math.sin(camRotX);
                    let cz = coreModel.position.z + hd * Math.cos(camRotX);
                    let cy = coreModel.position.y + h + vd;
                    cx += Math.cos(camRotX) * sh; cz -= Math.sin(camRotX) * sh;
                    camera.position.set(cx, cy, cz);
                    camera.lookAt(new THREE.Vector3(cx - Math.sin(camRotX) * 20, cy - Math.sin(camRotY) * 20, cz - Math.cos(camRotX) * 20));
                }
                renderer.render(scene, camera);
            }
            run();
        };
    </script>
</body>
</html>
