<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>新しいタブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #dcdcdc; font-family: sans-serif; }
        #gui-overlay { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.7); padding: 25px; border-radius: 12px;
            text-align: center; pointer-events: none; z-index: 200; font-weight: bold;
        }
        #ui-bar { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 300; }
        .item-slot {
            width: 60px; height: 60px; background: rgba(0, 0, 0, 0.6); border: 2px solid #555; border-radius: 8px;
            display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;
        }
        .item-slot.selected { border-color: #ffaa00; background: rgba(255, 170, 0, 0.4); }
    </style>
</head>
<body>
    <div id="gui-overlay">START APPLICATION<br>(1, 2, 3 / V: Squat)</div>
    <div id="ui-bar">
        <div class="item-slot selected" id="s-1">Mode 1</div>
        <div class="item-slot" id="s-2">Mode 2</div>
        <div class="item-slot" id="s-3">Special</div>
    </div>

    <script>
        let scene, camera, renderer, clock, mainMixer, coreModel;
        let vfxGroundMixer, vfxHandMixer; // それぞれ個別にミキサーを保持
        let keys = { q: false, e: false, c: false, s: false };
        let vertVel = 0, inAir = false, jumpReady = true, isLowPos = false, procActive = false;
        let activeIdx = 1, motionLib = {}, activeMotion;
        let r_mount, l_mount, subAsset, baseVfx, handVfx, projectiles = [], camRotX = 0, camRotY = 0.2;
        let isStandby = false;
        const gltfLoader = new THREE.GLTFLoader();

        function switchMotion(id, gap = 0.2) {
            const target = motionLib[id];
            if (target && activeMotion !== target) {
                if (activeMotion) activeMotion.fadeOut(gap);
                target.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(gap).play();
                activeMotion = target;
            }
        }

        async function updateMode(idx) {
            if (activeIdx === idx || procActive) return;
            if (activeIdx === 3) {
                isStandby = false;
                if (baseVfx) baseVfx.visible = false;
                if (handVfx) handVfx.visible = false;
                switchMotion('m_end', 0.2);
                await new Promise(r => setTimeout(r, 400));
            }
            activeIdx = idx;
            document.querySelectorAll('.item-slot').forEach((s, i) => s.classList.toggle('selected', i === idx - 1));
            if (subAsset) subAsset.visible = (idx === 2);
            if (idx === 3) {
                isStandby = true;
                switchMotion('m_start', 0.2);
                if (baseVfx) {
                    baseVfx.visible = true;
                    baseVfx.position.y = -1.0;
                    if (vfxGroundMixer) vfxGroundMixer.clipAction(baseVfx.animations[0]).reset().play();
                }
                if (handVfx) {
                    handVfx.visible = true;
                    handVfx.scale.set(0.11, 0.11, 0.11);
                    handVfx.rotation.set(Math.PI / 2, 0, 0); // 垂直に立てる
                }
                setTimeout(() => { if (activeIdx === 3) isStandby = false; }, 5000);
            } else { refreshMove(); }
        }

        function emitObj() {
            if (!l_mount) return;
            const pos = new THREE.Vector3();
            l_mount.getWorldPosition(pos);
            const offset = new THREE.Vector3(0, 0, 0.5).applyQuaternion(coreModel.quaternion);
            pos.add(offset);

            gltfLoader.load('./magicball.glb', (data) => {
                const obj = data.scene;
                obj.position.copy(pos);
                scene.add(obj);
                
                // 弾丸のアニメーション再生（もしあれば）
                let bMixer = null;
                if (data.animations.length > 0) {
                    bMixer = new THREE.AnimationMixer(obj);
                    data.animations.forEach(clip => bMixer.clipAction(clip).play());
                }
                
                const vec = new THREE.Vector3(0, 0, 1).applyQuaternion(coreModel.quaternion);
                projectiles.push({ mesh: obj, v: vec, ttl: 100, mixer: bMixer });
            });
        }

        function triggerAction() {
            if (procActive || inAir || isStandby) return;
            procActive = true;
            let mId = (activeIdx === 2) ? 'm_action2' : (activeIdx === 3 ? 'm_action3' : 'm_action1');
            if (activeIdx === 3) emitObj();
            switchMotion(mId, 0.1);
            setTimeout(() => { procActive = false; refreshMove(); }, 800);
        }

        function refreshMove() {
            if (procActive || inAir || (activeIdx === 3)) return;
            let dx = (keys.q ? -1 : 0) + (keys.c ? 1 : 0), dz = (keys.e ? -1 : 0) + (keys.s ? 1 : 0);
            if (dx !== 0 || dz !== 0) {
                if (isLowPos) switchMotion('m_low_walk', 0.2);
                else switchMotion((keys.e && !keys.s) ? 'm_fast' : 'm_walk', 0.2);
            } else {
                switchMotion(activeIdx === 2 ? 'm_idle2' : (isLowPos ? 'm_low_idle' : 'm_idle1'), 0.2);
            }
        }

        window.onload = function() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.5));
            scene.add(new THREE.GridHelper(500, 100, 0x999999, 0xcccccc));

            gltfLoader.load('./magic.glb', (d) => { 
                baseVfx = d.scene; baseVfx.visible = false; baseVfx.animations = d.animations;
                vfxGroundMixer = new THREE.AnimationMixer(baseVfx); scene.add(baseVfx); 
            });
            gltfLoader.load('./magic2.glb', (d) => { 
                handVfx = d.scene; handVfx.visible = false; 
                vfxHandMixer = new THREE.AnimationMixer(handVfx);
                if(d.animations.length > 0) d.animations.forEach(c => vfxHandMixer.clipAction(c).play());
                scene.add(handVfx); 
            });

            gltfLoader.load('./m.glb', (d) => {
                coreModel = d.scene; scene.add(coreModel);
                mainMixer = new THREE.AnimationMixer(coreModel);
                coreModel.traverse(n => {
                    if(n.isBone) {
                        const nm = n.name.toLowerCase();
                        if(nm.includes("hand") && nm.includes("l")) l_mount = n;
                        if(nm.includes("hand") && nm.includes("r")) r_mount = n;
                    }
                });

                gltfLoader.load('./sword.glb', (sd) => {
                    subAsset = sd.scene; subAsset.visible = false;
                    if(r_mount) { r_mount.add(subAsset); subAsset.rotation.set(Math.PI/2, 0, Math.PI); }
                });

                ['./a.glb', './b.glb'].forEach(u => {
                    gltfLoader.load(u, (ad) => {
                        ad.animations.forEach((clip, i) => {
                            clip.tracks = clip.tracks.filter(t => !t.name.endsWith('.position'));
                            const act = mainMixer.clipAction(clip);
                            if (clip.name === 'Idle_Loop') motionLib['m_idle1'] = act;
                            if (clip.name === 'Walk_Loop') motionLib['m_walk'] = act;
                            if (clip.name === 'Sprint_Loop') motionLib['m_fast'] = act;
                            if (clip.name === 'Jump_Start') { motionLib['m_j_s'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            if (clip.name === 'Jump_Loop') motionLib['m_j_l'] = act;
                            if (clip.name === 'Jump_Land') { motionLib['m_j_e'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            if (u === './b.glb') {
                                if (i === 1) motionLib['m_low_walk'] = act;
                                if (i === 2) motionLib['m_low_idle'] = act;
                                if (i === 25) { motionLib['m_action1'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 42) motionLib['m_idle2'] = act;
                                if (i === 40) { motionLib['m_action2'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 33) { motionLib['m_start'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 36) { motionLib['m_action3'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 34) { motionLib['m_end'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            }
                        });
                        if (motionLib['m_idle1']) switchMotion('m_idle1');
                    });
                });
            });

            window.onkeydown = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) keys[k] = true;
                if (k === 'v') isLowPos = !isLowPos;
                if (k === ' ' && !inAir && jumpReady && activeIdx !== 3) { 
                    inAir = true; jumpReady = false; vertVel = 0.18; switchMotion('m_j_s', 0.1); 
                }
                if (['1','2','3'].includes(k)) updateMode(parseInt(k));
            };
            window.onkeyup = (e) => { if (['e','s','q','c'].includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; };
            window.addEventListener('mousemove', (e) => { if (document.pointerLockElement === document.body) { camRotX -= e.movementX * 0.002; camRotY = Math.max(-0.7, Math.min(1.1, camRotY + e.movementY * 0.002)); } });
            document.body.addEventListener('mousedown', () => { if(document.pointerLockElement !== document.body) { document.body.requestPointerLock(); document.getElementById('gui-overlay').style.display = 'none'; } else triggerAction(); });

            function animate() {
                requestAnimationFrame(animate);
                const dt = clock.getDelta();
                if (mainMixer) mainMixer.update(dt);
                if (vfxGroundMixer) vfxGroundMixer.update(dt);
                if (vfxHandMixer) vfxHandMixer.update(dt);

                if (coreModel) {
                    if (!procActive && activeIdx !== 3) {
                        let dx = (keys.q ? -1 : 0) + (keys.c ? 1 : 0), dz = (keys.e ? -1 : 0) + (keys.s ? 1 : 0);
                        if (dx !== 0 || dz !== 0) {
                            const targetRot = Math.atan2(dx, dz) + camRotX;
                            let diff = targetRot - coreModel.rotation.y;
                            while (diff < -Math.PI) diff += Math.PI * 2;
                            while (diff > Math.PI) diff -= Math.PI * 2;
                            coreModel.rotation.y += diff * 0.15;
                            const speed = (keys.e && !keys.s && !isLowPos) ? 0.14 : 0.07;
                            coreModel.position.x += Math.sin(coreModel.rotation.y) * speed;
                            coreModel.position.z += Math.cos(coreModel.rotation.y) * speed;
                        }
                    }
                    refreshMove();

                    if (baseVfx && baseVfx.visible) {
                        baseVfx.position.set(coreModel.position.x, baseVfx.position.y, coreModel.position.z);
                        if (baseVfx.position.y < 0) baseVfx.position.y += 0.01;
                    }
                    if (handVfx && handVfx.visible && l_mount) {
                        const p = new THREE.Vector3(); l_mount.getWorldPosition(p);
                        const offset = new THREE.Vector3(0, 0, 0.3).applyQuaternion(coreModel.quaternion);
                        handVfx.position.copy(p).add(offset);
                        handVfx.rotation.y = coreModel.rotation.y;
                    }
                    for (let i = projectiles.length - 1; i >= 0; i--) {
                        projectiles[i].mesh.position.add(projectiles[i].v.clone().multiplyScalar(0.4));
                        if (projectiles[i].mixer) projectiles[i].mixer.update(dt);
                        if (projectiles[i].ttl-- <= 0) { scene.remove(projectiles[i].mesh); projectiles.splice(i, 1); }
                    }

                    if (inAir) {
                        coreModel.position.y += vertVel; vertVel -= 0.008;
                        if (coreModel.position.y <= 0) { coreModel.position.y = 0; inAir = false; setTimeout(() => { jumpReady = true; refreshMove(); }, 300); }
                    } else {
                        const ty = (isLowPos && activeIdx !== 3) ? -0.4 : 0;
                        coreModel.position.y += (ty - coreModel.position.y) * 0.1;
                    }
                    camera.position.set(coreModel.position.x + (2.4 * Math.cos(camRotY)) * Math.sin(camRotX), coreModel.position.y + 1.5 + (2.4 * Math.sin(camRotY)), coreModel.position.z + (2.4 * Math.cos(camRotY)) * Math.cos(camRotX));
                    camera.lookAt(coreModel.position.x, coreModel.position.y + 1.2, coreModel.position.z);
                }
                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
