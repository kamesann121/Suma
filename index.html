<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新しいタブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #dcdcdc; font-family: sans-serif; }
        #ui-sidebar { 
            position: fixed; top: 0; left: 0; width: 170px; height: 100vh; 
            background: rgba(255,255,255,0.9); border-right: 1px solid #ccc;
            display: flex; flex-direction: column; gap: 4px; padding: 10px;
            overflow-y: auto; z-index: 100; box-sizing: border-box;
        }
        #ui-sidebar button { width: 100%; padding: 6px; background: #fff; border: 1px solid #999; border-radius: 4px; font-size: 10px; cursor: pointer; text-align: left; }
    </style>
</head>
<body>
    <div id="ui-sidebar"></div>

    <script>
        let scene, camera, renderer, clock, mixer, model, controls;
        let moveState = { q: false, e: false, c: false, s: false };
        let velocityY = 0, isJumping = false;
        let actions = {}, currentAction;

        function fadeToAction(name, duration = 0.2) {
            const nextAction = actions[name];
            if (nextAction && currentAction !== nextAction) {
                if (currentAction) currentAction.fadeOut(duration);
                nextAction.reset().fadeIn(duration).play();
                currentAction = nextAction;
            }
        }

        window.onload = function() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 6);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 【修正】マウスで視点を自由に動かせるように復活
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.enablePan = false; 

            scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.5));
            scene.add(new THREE.GridHelper(100, 100, 0x999999, 0xcccccc));

            const loader = new THREE.GLTFLoader();
            loader.load('./m.glb', (gltf) => {
                model = gltf.scene;
                scene.add(model);
                mixer = new THREE.AnimationMixer(model);

                ['./a.glb', './b.glb'].forEach(url => {
                    loader.load(url, (animGltf) => {
                        animGltf.animations.forEach((clip, i) => {
                            clip.tracks = clip.tracks.filter(t => !t.name.endsWith('.position'));
                            const action = mixer.clipAction(clip);
                            const keyName = `${url.replace('./','')}_${clip.name || i}`;
                            actions[keyName] = action;
                            if (clip.name.includes("Walk_Loop")) actions['walk'] = action;
                            if (url === './a.glb' && i === 0) actions['idle'] = action;

                            const btn = document.createElement('button');
                            btn.innerText = keyName;
                            btn.onclick = () => fadeToAction(keyName);
                            document.getElementById('ui-sidebar').appendChild(btn);
                        });
                        if (actions['idle']) fadeToAction('idle');
                    });
                });
            });

            window.onkeydown = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) moveState[k] = true;
                if (k === ' ' && !isJumping) { isJumping = true; velocityY = 0.15; }
            };
            window.onkeyup = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) moveState[k] = false;
            };

            clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                if (mixer) mixer.update(delta);
                if (controls) controls.update();

                if (model) {
                    let inputX = 0;
                    let inputZ = 0;

                    if (moveState.e) inputZ -= 1; 
                    if (moveState.s) inputZ += 1; 
                    if (moveState.q) inputX -= 1; 
                    if (moveState.c) inputX += 1; 

                    if (inputX !== 0 || inputZ !== 0) {
                        // 【重要】カメラの向きを取得（Y軸の回転のみ）
                        const cameraY = Math.atan2(camera.position.x - model.position.x, camera.position.z - model.position.z);
                        
                        // 入力方向の計算
                        const moveAngle = Math.atan2(inputX, inputZ);
                        
                        // モデルが向くべき方向（カメラの向き ＋ 入力方向）
                        const targetRotation = moveAngle + cameraY + Math.PI;

                        // 【修正】スムーズに回転させる処理
                        let diff = targetRotation - model.rotation.y;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        model.rotation.y += diff * 0.15;

                        // 【修正】現在向いている方向へ進む
                        const speed = 0.08;
                        model.position.x += Math.sin(model.rotation.y) * speed;
                        model.position.z += Math.cos(model.rotation.y) * speed;

                        fadeToAction('walk');
                    } else {
                        if (!isJumping) fadeToAction('idle');
                    }

                    if (isJumping) {
                        model.position.y += velocityY;
                        velocityY -= 0.008;
                        if (model.position.y <= 0) { model.position.y = 0; isJumping = false; }
                    }

                    // カメラの注視点を常にモデルの腰あたりに固定（移動に追従）
                    controls.target.set(model.position.x, model.position.y + 1.2, model.position.z);
                }
                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
