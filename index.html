<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.19.0/dist/cannon-es.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #overlay { position: fixed; top: 20px; left: 20px; color: #0f0; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 5px; font-size: 12px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="overlay">
        CONTROLS UPDATED<br>
        - Vキー: 0.2秒間隔で切り替え可能<br>
        - しゃがみ歩きモーション優先度修正済
    </div>

    <script type="module">
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.19.0/dist/cannon-es.js';

        let scene, camera, renderer, clock, mixer, model;
        let world, characterBody, debugSphere; 
        let moveState = { q: false, e: false, c: false, s: false };
        let isJumping = false, canJump = true, isCrouching = false;
        let lastCrouchTime = 0; // しゃがみクールタイム用
        let actions = {}, currentAction;
        let cameraAzimuth = 0, cameraElevation = 0.2;

        const RADIUS = 0.4;
        const OFFSET_STAND = 0.05;
        const OFFSET_CROUCH = 0.35; 
        let currentVisualOffset = OFFSET_STAND;
        let smoothCameraTargetY = 0;

        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            const floorBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(floorBody);
            characterBody = new CANNON.Body({ mass: 1, shape: new CANNON.Sphere(RADIUS), fixedRotation: true, linearDamping: 0.9 });
            characterBody.position.set(0, 2, 0); 
            world.addBody(characterBody);
        }

        window.onload = function() {
            initPhysics();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({ color: 0x111111 })));
            const grid = new THREE.GridHelper(1000, 200, 0x333333, 0x666666);
            grid.position.y = -0.01; 
            scene.add(grid);
            debugSphere = new THREE.Mesh(new THREE.SphereGeometry(RADIUS), new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true }));
            scene.add(debugSphere);
            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));

            document.body.addEventListener('click', () => document.body.requestPointerLock());

            const loader = new THREE.GLTFLoader();
            loader.load('./m.glb', (gltf) => {
                model = gltf.scene;
                scene.add(model);
                mixer = new THREE.AnimationMixer(model);
                ['./a.glb', './b.glb'].forEach(url => {
                    loader.load(url, (animGltf) => {
                        animGltf.animations.forEach((clip) => {
                            clip.tracks = clip.tracks.filter(t => !t.name.endsWith('.position'));
                            const action = mixer.clipAction(clip);
                            if (clip.name === 'Idle_Loop') actions['idle'] = action;
                            if (clip.name === 'Walk_Loop') actions['walk'] = action;
                            if (clip.name === 'Sprint_Loop') actions['run'] = action;
                            if (clip.name === 'Jump_Start') { action.setLoop(THREE.LoopOnce); action.clampWhenFinished = true; actions['jump_start'] = action; }
                            if (clip.name === 'Jump_Loop') actions['jump_loop'] = action;
                            if (clip.name === 'Jump_Land') { action.setLoop(THREE.LoopOnce); action.clampWhenFinished = true; actions['jump_land'] = action; }
                            
                            // しゃがみモーションの取得方法を強化
                            if (url.includes('b.glb')) {
                                if (clip.name.toLowerCase().includes('crouch') && clip.name.toLowerCase().includes('walk')) actions['crouch_walk'] = action;
                                else if (clip.name.toLowerCase().includes('crouch') && clip.name.toLowerCase().includes('idle')) actions['crouch_idle'] = action;
                            }
                        });
                        if (actions['idle'] && !currentAction) {
                            actions['idle'].play();
                            currentAction = actions['idle'];
                        }
                    });
                });
            });

            window.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body) {
                    cameraAzimuth -= e.movementX * 0.002;
                    cameraElevation = Math.max(-0.4, Math.min(1.2, cameraElevation + e.movementY * 0.002));
                }
            });

            window.onkeydown = (e) => {
                const k = e.key.toLowerCase();
                if (['e', 's', 'q', 'c'].includes(k)) moveState[k] = true;
                
                // しゃがみ切り替え（0.2秒のクールタイム）
                const now = Date.now();
                if (k === 'v' && now - lastCrouchTime > 200) {
                    isCrouching = !isCrouching;
                    lastCrouchTime = now;
                }

                if (k === ' ' && !isJumping && canJump) { 
                    characterBody.velocity.y = 8;
                    isJumping = true; canJump = false;
                    fadeToAction('jump_start', 0.1);
                }
            };

            window.onkeyup = (e) => {
                const k = e.key.toLowerCase();
                if (['e', 's', 'q', 'c'].includes(k)) moveState[k] = false;
            };

            clock = new THREE.Clock();

            function fadeToAction(name, duration = 0.2) {
                const nextAction = actions[name];
                if (nextAction && currentAction !== nextAction) {
                    if (currentAction) currentAction.fadeOut(duration);
                    nextAction.reset().fadeIn(duration).play();
                    currentAction = nextAction;
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                world.fixedStep();
                const delta = clock.getDelta();
                if (mixer) mixer.update(delta);

                if (model && characterBody) {
                    let inputX = (moveState.q ? -1 : 0) + (moveState.c ? 1 : 0);
                    let inputZ = (moveState.e ? -1 : 0) + (moveState.s ? 1 : 0);
                    let isMoving = (inputX !== 0 || inputZ !== 0);

                    if (isMoving) {
                        const targetRot = Math.atan2(inputX, inputZ) + cameraAzimuth;
                        model.rotation.y += (targetRot - model.rotation.y) * 0.15;
                        
                        // 移動速度の設定
                        let speed = 3;
                        if (isCrouching) {
                            speed = 1.5; // しゃがみ歩きは遅く
                            if (!isJumping) fadeToAction('crouch_walk', 0.2);
                        } else {
                            speed = (moveState.e && !moveState.q && !moveState.c) ? 6 : 3;
                            if (!isJumping) fadeToAction(speed > 4 ? 'run' : 'walk', 0.2);
                        }
                        
                        characterBody.velocity.x = Math.sin(model.rotation.y) * speed;
                        characterBody.velocity.z = Math.cos(model.rotation.y) * speed;
                    } else {
                        characterBody.velocity.x *= 0.8; characterBody.velocity.z *= 0.8;
                        if (!isJumping) fadeToAction(isCrouching ? 'crouch_idle' : 'idle', 0.2);
                    }

                    // 接地補正の計算
                    const targetOffset = isCrouching ? OFFSET_CROUCH : OFFSET_STAND;
                    currentVisualOffset += (targetOffset - currentVisualOffset) * 0.1;

                    debugSphere.position.copy(characterBody.position);
                    model.position.set(
                        characterBody.position.x,
                        characterBody.position.y - (RADIUS + currentVisualOffset), 
                        characterBody.position.z
                    );

                    const targetY = model.position.y + 1.2;
                    smoothCameraTargetY += (targetY - smoothCameraTargetY) * 0.1;
                    const dist = 5;
                    camera.position.set(
                        model.position.x + dist * Math.sin(cameraAzimuth) * Math.cos(cameraElevation),
                        smoothCameraTargetY + 0.6 + dist * Math.sin(cameraElevation),
                        model.position.z + dist * Math.cos(cameraAzimuth) * Math.cos(cameraElevation)
                    );
                    camera.lookAt(model.position.x, smoothCameraTargetY, model.position.z);

                    if (isJumping && characterBody.position.y <= RADIUS + 0.1) {
                        isJumping = false;
                        fadeToAction('jump_land', 0.1);
                        setTimeout(() => { canJump = true; }, 300);
                    }
                }
                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
