<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新しいタブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #dcdcdc; font-family: sans-serif; }
        #overlay { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.7); padding: 25px; border-radius: 12px;
            text-align: center; pointer-events: none; z-index: 200; font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="overlay">CLICK TO START<br>(E: Run / Q,C,S: Walk / Space: Jump)</div>

    <script>
        let scene, camera, renderer, clock, mixer, model;
        let moveState = { q: false, e: false, c: false, s: false };
        let velocityY = 0, isJumping = false, canJump = true; // ジャンプ管理
        let actions = {}, currentAction;
        let cameraAzimuth = 0, cameraElevation = 0.2;

        function fadeToAction(name, duration = 0.2) {
            const nextAction = actions[name];
            if (nextAction && currentAction !== nextAction) {
                if (currentAction) currentAction.fadeOut(duration);
                nextAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
                currentAction = nextAction;
            }
        }

        window.onload = function() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.5));
            scene.add(new THREE.GridHelper(500, 100, 0x999999, 0xcccccc));

            document.body.addEventListener('click', () => {
                document.body.requestPointerLock();
                document.getElementById('overlay').style.display = 'none';
            });

            const loader = new THREE.GLTFLoader();
            loader.load('./m.glb', (gltf) => {
                model = gltf.scene;
                scene.add(model);
                mixer = new THREE.AnimationMixer(model);

                ['./a.glb', './b.glb'].forEach(url => {
                    loader.load(url, (animGltf) => {
                        animGltf.animations.forEach((clip) => {
                            clip.tracks = clip.tracks.filter(t => !t.name.endsWith('.position'));
                            const action = mixer.clipAction(clip);
                            const name = clip.name;

                            if (name === 'Idle_Loop') actions['idle'] = action;
                            if (name === 'Walk_Loop') actions['walk'] = action;
                            if (name === 'Sprint_Loop') actions['run'] = action;
                            if (name === 'Jump_Start') {
                                actions['jump_start'] = action;
                                action.setLoop(THREE.LoopOnce);
                                action.clampWhenFinished = true;
                            }
                            if (name === 'Jump_Loop') actions['jump_loop'] = action;
                            if (name === 'Jump_Land') {
                                actions['jump_land'] = action;
                                action.setLoop(THREE.LoopOnce);
                                action.clampWhenFinished = true;
                            }
                        });
                        if (actions['idle']) fadeToAction('idle');
                    });
                });
            });

            window.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body) {
                    cameraAzimuth -= e.movementX * 0.002;
                    cameraElevation = Math.max(-0.4, Math.min(1.2, cameraElevation + e.movementY * 0.002));
                }
            });

            window.onkeydown = (e) => {
                if (e.repeat) return; // 【修正】キー長押しによる連続入力を無視
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) moveState[k] = true;

                // 【修正】ジャンプ可否判定（クールタイム中または空中なら不可）
                if (k === ' ' && !isJumping && canJump) { 
                    isJumping = true;
                    canJump = false; 
                    velocityY = 0.18; 
                    fadeToAction('jump_start', 0.1);
                }
            };

            window.onkeyup = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) moveState[k] = false;
            };

            clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                if (mixer) mixer.update(delta);

                if (model) {
                    let inputX = 0, inputZ = 0;
                    if (moveState.e) inputZ -= 1;
                    if (moveState.s) inputZ += 1;
                    if (moveState.q) inputX -= 1;
                    if (moveState.c) inputX += 1;

                    const isMoving = (inputX !== 0 || inputZ !== 0);

                    if (isMoving) {
                        const targetRotation = Math.atan2(inputX, inputZ) + cameraAzimuth;
                        let diff = targetRotation - model.rotation.y;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        model.rotation.y += diff * 0.15;

                        // 【仕様変更】E（前進）のみの入力、かつ他が押されていない場合は走り、それ以外は歩き
                        const onlyForward = (moveState.e && !moveState.s && !moveState.q && !moveState.c);
                        let speed = onlyForward ? 0.14 : 0.07;
                        
                        model.position.x += Math.sin(model.rotation.y) * speed;
                        model.position.z += Math.cos(model.rotation.y) * speed;

                        // 【修正】空中でない時のみ移動アニメ再生
                        if (!isJumping) {
                            if (onlyForward) fadeToAction('run', 0.2); 
                            else fadeToAction('walk', 0.2);
                        }
                    } else {
                        if (!isJumping) fadeToAction('idle', 0.2);
                    }

                    if (isJumping) {
                        model.position.y += velocityY;
                        velocityY -= 0.008;

                        if (velocityY < 0 && currentAction === actions['jump_start']) {
                            fadeToAction('jump_loop', 0.3);
                        }

                        if (model.position.y <= 0) {
                            model.position.y = 0;
                            isJumping = false;
                            fadeToAction('jump_land', 0.1);
                            
                            // 【修正】着地から0.5秒後に再度ジャンプ可能にする
                            setTimeout(() => {
                                canJump = true;
                                if (isMoving) {
                                    const onlyForward = (moveState.e && !moveState.s && !moveState.q && !moveState.c);
                                    fadeToAction(onlyForward ? 'run' : 'walk', 0.2);
                                } else {
                                    fadeToAction('idle', 0.2);
                                }
                            }, 500);
                        }
                    }

                    const dist = 5;
                    camera.position.set(
                        model.position.x + dist * Math.sin(cameraAzimuth) * Math.cos(cameraElevation),
                        model.position.y + 1.8 + dist * Math.sin(cameraElevation),
                        model.position.z + dist * Math.cos(cameraAzimuth) * Math.cos(cameraElevation)
                    );
                    camera.lookAt(model.position.x, model.position.y + 1.2, model.position.z);
                }
                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
