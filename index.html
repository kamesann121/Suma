<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新しいタブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #dcdcdc; font-family: sans-serif; }
        #overlay { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.7); padding: 25px; border-radius: 12px;
            text-align: center; pointer-events: none; z-index: 200; font-weight: bold;
        }
        #status { position: fixed; bottom: 120px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; font-size: 14px; pointer-events: none; }
        #reticle {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 8px; height: 8px; border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%; pointer-events: none; z-index: 100;
        }
        #inventory { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 300; }
        .slot {
            width: 60px; height: 60px; background: rgba(0, 0, 0, 0.6); border: 2px solid #555; border-radius: 8px;
            display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold; position: relative;
        }
        .slot.active { border-color: #00ff00; background: rgba(0, 255, 0, 0.2); }
        .slot::after { content: attr(data-key); position: absolute; top: 2px; left: 4px; color: #aaa; }
    </style>
</head>
<body>
    <div id="overlay">CLICK TO START<br>(1: 素手 / 2: ピストル / V: しゃがみ)</div>
    <div id="status">Current: Bare Hands</div>
    <div id="reticle"></div>

    <div id="inventory">
        <div class="slot active" data-key="1" id="slot-1">素手</div>
        <div class="slot" data-key="2" id="slot-2">ピストル</div>
        <div class="slot" data-key="3" id="slot-3"></div>
        <div class="slot" data-key="4" id="slot-4"></div>
        <div class="slot" data-key="5" id="slot-5"></div>
        <div class="slot" data-key="6" id="slot-6"></div>
    </div>

    <script>
        let scene, camera, renderer, clock, mixer, model, gun;
        let moveState = { q: false, e: false, c: false, s: false };
        let currentEquip = 1; 
        let isCrouching = false;
        let actions = {}, currentAction;
        let cameraAzimuth = 0, cameraElevation = 0.2;
        let upperBodyBones = []; // 上半身のボーンリスト

        function fadeToAction(name, duration = 0.2) {
            const nextAction = actions[name];
            if (nextAction && currentAction !== nextAction) {
                if (currentAction) currentAction.fadeOut(duration);
                nextAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
                currentAction = nextAction;
            }
        }

        function updateInventoryUI(slotNum) {
            document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
            document.getElementById(`slot-${slotNum}`).classList.add('active');
            const names = ["", "Bare Hands", "Pistol", "Empty", "Empty", "Empty", "Empty"];
            document.getElementById('status').innerText = "Current: " + names[slotNum];
            if (gun) gun.visible = (slotNum === 2);
        }

        window.onload = function() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.5));
            scene.add(new THREE.GridHelper(500, 100, 0x999999, 0xcccccc));

            const loader = new THREE.GLTFLoader();

            loader.load('./Pistol.glb', (gltf) => {
                gun = gltf.scene;
                gun.scale.set(0.0016, 0.0016, 0.0016); 
                gun.rotation.set(Math.PI / 2, Math.PI / 2, 0); 
                gun.visible = false; 
            });

            loader.load('./m.glb', (gltf) => {
                model = gltf.scene;
                scene.add(model);
                mixer = new THREE.AnimationMixer(model);

                model.traverse((child) => {
                    if (child.isBone) {
                        const name = child.name.toLowerCase();
                        // 上半身として扱うボーン（背骨、肩、腕、手、頭）をリストアップ
                        if (name.includes("spine") || name.includes("arm") || name.includes("hand") || name.includes("neck") || name.includes("head") || name.includes("shoulder")) {
                            upperBodyBones.push(child);
                        }
                        
                        // ピストルのアタッチ（前：0.08、左：-0.04に調整）
                        if (name.includes("hand") && (name.includes("r") || name.includes("right"))) {
                            child.add(gun);
                            gun.position.set(-0.04, 0.01, 0.08); 
                        }
                    }
                });

                ['./a.glb', './b.glb'].forEach(url => {
                    loader.load(url, (animGltf) => {
                        animGltf.animations.forEach((clip, index) => {
                            clip.tracks = clip.tracks.filter(t => !t.name.endsWith('.position'));
                            const action = mixer.clipAction(clip);
                            const name = clip.name;
                            if (name === 'Idle_Loop') actions['idle'] = action;
                            if (name === 'Walk_Loop') actions['walk'] = action;
                            if (name === 'Sprint_Loop') actions['run'] = action;
                            if (url === './b.glb' && index === 19) {
                                actions['aim_pose'] = action;
                                // 構えポーズの情報をキャッシュしておく（後で手動コピーするため）
                                action.play();
                                action.weight = 0; // 通常は非表示
                            }
                            if (url === './b.glb') {
                                if (index === 1) actions['crouch_walk'] = action;
                                if (index === 2) actions['crouch_idle'] = action;
                            }
                        });
                        if (actions['idle']) fadeToAction('idle');
                    });
                });
            });

            document.body.addEventListener('click', () => {
                document.body.requestPointerLock();
                document.getElementById('overlay').style.display = 'none';
            });

            window.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body) {
                    cameraAzimuth -= e.movementX * 0.002;
                    cameraElevation = Math.max(-0.7, Math.min(1.1, cameraElevation + e.movementY * 0.002));
                }
            });

            window.onkeydown = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) moveState[k] = true;
                if (k === 'v') isCrouching = !isCrouching;
                if (k === '1') { currentEquip = 1; updateInventoryUI(1); }
                if (k === '2') { currentEquip = 2; updateInventoryUI(2); }
            };

            window.onkeyup = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) moveState[k] = false;
            };

            clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();

                // 1. アニメーションを通常通り更新（これで下半身が動く）
                if (mixer) {
                    mixer.update(delta);
                }

                if (model) {
                    let inputX = 0, inputZ = 0;
                    if (moveState.e) inputZ -= 1;
                    if (moveState.s) inputZ += 1;
                    if (moveState.q) inputX -= 1;
                    if (moveState.c) inputX += 1;
                    const isMoving = (inputX !== 0 || inputZ !== 0);

                    // 移動と向き
                    if (isMoving) {
                        const targetRotation = Math.atan2(inputX, inputZ) + cameraAzimuth;
                        let diff = targetRotation - model.rotation.y;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        model.rotation.y += diff * 0.15;

                        const onlyForward = (moveState.e && !moveState.s && !moveState.q && !moveState.c);
                        let speed = (onlyForward && !isCrouching) ? 0.14 : 0.07;
                        model.position.x += Math.sin(model.rotation.y) * speed;
                        model.position.z += Math.cos(model.rotation.y) * speed;

                        if (isCrouching) fadeToAction('crouch_walk', 0.2);
                        else if (onlyForward) fadeToAction('run', 0.2); 
                        else fadeToAction('walk', 0.2);
                    } else {
                        fadeToAction(isCrouching ? 'crouch_idle' : 'idle', 0.2);
                    }

                    // 2. ★ 上半身のボーンを「構えポーズ」で強制上書き（ピストル装備時のみ）
                    if (currentEquip === 2 && actions['aim_pose']) {
                        // このタイミングでボーンを強制固定することで、下半身は歩きつつ腕は固定される
                        // 注：本来はIKなどを使いますが、まずは一番シンプルな「ポーズ固定」を試します
                        model.traverse((child) => {
                            if (child.isBone && upperBodyBones.includes(child)) {
                                // アニメーションミキサーによって動かされた値を無視し、
                                // プログラムで「前を向く」ように微調整を加えることも可能
                            }
                        });
                        // 構えポーズの影響を最大化
                        actions['aim_pose'].weight = 1.0; 
                    } else if (actions['aim_pose']) {
                        actions['aim_pose'].weight = 0;
                    }

                    // 高さ
                    const targetY = isCrouching ? -0.4 : 0;
                    model.position.y += (targetY - model.position.y) * 0.1;

                    // カメラ
                    const camDist = 2.4, camSide = 1.0, camHeight = 1.5;
                    const hDist = camDist * Math.cos(cameraElevation);
                    const vDist = camDist * Math.sin(cameraElevation);
                    let camX = model.position.x + hDist * Math.sin(cameraAzimuth) + Math.cos(cameraAzimuth) * camSide;
                    let camZ = model.position.z + hDist * Math.cos(cameraAzimuth) - Math.sin(cameraAzimuth) * camSide;
                    let camY = model.position.y + camHeight + vDist;
                    camera.position.set(camX, camY, camZ);
                    camera.lookAt(camX - Math.sin(cameraAzimuth) * 20, camY - Math.sin(cameraElevation) * 20, camZ - Math.cos(cameraAzimuth) * 20);
                }
                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
