<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新しいタブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #dcdcdc; font-family: sans-serif; }
        #overlay { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.7); padding: 25px; border-radius: 12px;
            text-align: center; pointer-events: none; z-index: 200; font-weight: bold;
        }
        #inventory { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 300; }
        .slot {
            width: 60px; height: 60px; background: rgba(0, 0, 0, 0.6); border: 2px solid #555; border-radius: 8px;
            display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold;
        }
        .slot.active { border-color: #ffaa00; background: rgba(255, 170, 0, 0.4); }
    </style>
</head>
<body>
    <div id="overlay">CLICK TO START<br>(1:殴り 2:剣 3:魔法)</div>

    <div id="inventory">
        <div class="slot active" id="slot-1">殴り</div>
        <div class="slot" id="slot-2">剣</div>
        <div class="slot" id="slot-3">魔法</div>
    </div>

    <script>
        let scene, camera, renderer, clock, mixer, model;
        let moveState = { q: false, e: false, c: false, s: false };
        let velocityY = 0, isJumping = false, canJump = true, isCrouching = false, isAttacking = false;
        let currentEquip = 1, actions = {}, currentAction;
        let rightHandBone, leftHandBone, swordMesh; // ボーンと武器の変数
        let vfxGround, vfxFront, magicBalls = [], cameraAzimuth = 0, cameraElevation = 0.2;
        const loader = new THREE.GLTFLoader();

        function fadeToAction(name, duration = 0.2) {
            const nextAction = actions[name];
            if (nextAction && currentAction !== nextAction) {
                if (currentAction) currentAction.fadeOut(duration);
                nextAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
                currentAction = nextAction;
            }
        }

        async function changeEquip(newSlot) {
            if (currentEquip === newSlot || isAttacking) return;
            
            // 魔法解除のアニメーション
            if (currentEquip === 3) {
                fadeToAction('magic_end', 0.2);
                await new Promise(r => setTimeout(r, 400));
            }

            currentEquip = newSlot;
            document.querySelectorAll('.slot').forEach((s, i) => s.classList.toggle('active', i === newSlot - 1));

            // 剣の表示・非表示切り替え
            if (swordMesh) swordMesh.visible = (newSlot === 2);

            if (newSlot === 3) fadeToAction('magic_start', 0.2);
            else updateMotion();
        }

        function fireMagicBall() {
            if (!leftHandBone || !vfxFront) return;

            // 左手の座標を取得
            const handPos = new THREE.Vector3();
            leftHandBone.getWorldPosition(handPos);

            // 発射魔法陣（左手位置、1/3サイズ）
            vfxFront.visible = true;
            vfxFront.scale.set(0.33, 0.33, 0.33);
            vfxFront.position.copy(handPos);
            vfxFront.quaternion.copy(model.quaternion);
            setTimeout(() => { vfxFront.visible = false; }, 500);

            // 魔法弾（左手から発射）
            loader.load('./magicball.glb', (gltf) => {
                const ball = gltf.scene;
                ball.position.copy(handPos);
                const direction = new THREE.Vector3(0, 0, 1).applyQuaternion(model.quaternion);
                scene.add(ball);
                magicBalls.push({ mesh: ball, dir: direction, life: 100 });
            });
        }

        function performAttack() {
            if (isAttacking || isJumping) return;
            isAttacking = true;

            let anim = (currentEquip === 2) ? 'sword_attack' : (currentEquip === 3 ? 'magic_fire' : 'punch');
            if (currentEquip === 3) fireMagicBall();

            fadeToAction(anim, 0.1);
            
            setTimeout(() => {
                isAttacking = false;
                updateMotion();
            }, 800);
        }

        function updateMotion() {
            if (isAttacking || isJumping) return;
            let inputX = (moveState.q ? -1 : 0) + (moveState.c ? 1 : 0);
            let inputZ = (moveState.e ? -1 : 0) + (moveState.s ? 1 : 0);
            const isMoving = (inputX !== 0 || inputZ !== 0);

            if (isMoving) {
                if (isCrouching) fadeToAction('crouch_walk', 0.2);
                else fadeToAction((moveState.e && !moveState.s && !moveState.q && !moveState.c) ? 'run' : 'walk', 0.2);
            } else {
                if (currentEquip === 2) fadeToAction('sword_idle', 0.2);
                else if (currentEquip === 3) fadeToAction('magic_pose', 0.3);
                else fadeToAction(isCrouching ? 'crouch_idle' : 'idle', 0.2);
            }
        }

        window.onload = function() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.5));
            scene.add(new THREE.GridHelper(500, 100, 0x999999, 0xcccccc));

            document.body.addEventListener('mousedown', (e) => {
                if(document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                    document.getElementById('overlay').style.display = 'none';
                } else if (e.button === 0) performAttack();
            });

            // 素材ロード
            loader.load('./magic.glb', (gltf) => { vfxGround = gltf.scene; vfxGround.visible = false; scene.add(vfxGround); });
            loader.load('./magic2.glb', (gltf) => { vfxFront = gltf.scene; vfxFront.visible = false; scene.add(vfxFront); });

            loader.load('./m.glb', (gltf) => {
                model = gltf.scene;
                scene.add(model);
                mixer = new THREE.AnimationMixer(model);

                // 両手のボーンを特定
                model.traverse(n => {
                    if(n.isBone) {
                        const name = n.name.toLowerCase();
                        if(name.includes("hand") && name.includes("l")) leftHandBone = n;
                        if(name.includes("hand") && name.includes("r")) rightHandBone = n;
                    }
                });

                // 剣のロードと右手への装備
                loader.load('./sword.glb', (gltf) => {
                    swordMesh = gltf.scene;
                    swordMesh.visible = false; // 最初は隠す
                    if(rightHandBone) {
                        rightHandBone.add(swordMesh);
                        // 剣の位置や向きの微調整（モデルに合わせて適宜変更してください）
                        swordMesh.rotation.x = Math.PI / 2;
                        swordMesh.position.set(0, 0, 0);
                    }
                });

                ['./a.glb', './b.glb'].forEach(url => {
                    loader.load(url, (animGltf) => {
                        animGltf.animations.forEach((clip, index) => {
                            clip.tracks = clip.tracks.filter(t => !t.name.endsWith('.position'));
                            const action = mixer.clipAction(clip);
                            if (clip.name === 'Idle_Loop') actions['idle'] = action;
                            if (clip.name === 'Walk_Loop') actions['walk'] = action;
                            if (clip.name === 'Sprint_Loop') actions['run'] = action;
                            if (clip.name.includes('Jump')) actions[clip.name.toLowerCase()] = action;
                            
                            if (url === './b.glb') {
                                if (index === 1) actions['crouch_walk'] = action;
                                if (index === 2) actions['crouch_idle'] = action;
                                if (index === 25) actions['punch'] = action;
                                if (index === 42) actions['sword_idle'] = action;
                                if (index === 40) actions['sword_attack'] = action;
                                if (index === 33) actions['magic_start'] = action;
                                if (index === 35) actions['magic_pose'] = action;
                                if (index === 36) actions['magic_fire'] = action;
                                if (index === 34) actions['magic_end'] = action;
                                if ([25, 40, 33, 34, 36].includes(index)) action.setLoop(THREE.LoopOnce);
                            }
                        });
                        if (actions['idle']) fadeToAction('idle');
                    });
                });
            });

            window.onkeydown = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) moveState[k] = true;
                if (k === 'v') isCrouching = !isCrouching;
                if (k === ' ' && !isJumping && canJump) { isJumping = true; canJump = false; velocityY = 0.18; fadeToAction('jump_start', 0.1); }
                if (['1','2','3'].includes(k)) changeEquip(parseInt(k));
            };
            window.onkeyup = (e) => { if (['e','s','q','c'].includes(e.key.toLowerCase())) moveState[e.key.toLowerCase()] = false; };
            window.addEventListener('mousemove', (e) => { if (document.pointerLockElement === document.body) { cameraAzimuth -= e.movementX * 0.002; cameraElevation = Math.max(-0.4, Math.min(1.2, cameraElevation + e.movementY * 0.002)); } });

            clock = new THREE.Clock();
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                if (mixer) mixer.update(delta);
                if (model) {
                    let inputX = (moveState.q ? -1 : 0) + (moveState.c ? 1 : 0);
                    let inputZ = (moveState.e ? -1 : 0) + (moveState.s ? 1 : 0);
                    if ((inputX !== 0 || inputZ !== 0) && !isAttacking) {
                        model.rotation.y = Math.atan2(inputX, inputZ) + cameraAzimuth;
                        let speed = (moveState.e && !isCrouching && !moveState.s && !moveState.q && !moveState.c) ? 0.14 : 0.07;
                        model.position.x += Math.sin(model.rotation.y) * speed;
                        model.position.z += Math.cos(model.rotation.y) * speed;
                    }
                    updateMotion();

                    if (vfxGround) {
                        vfxGround.visible = (currentEquip === 3);
                        vfxGround.position.copy(model.position);
                    }
                    if (vfxFront && vfxFront.visible && leftHandBone) {
                        const handPos = new THREE.Vector3();
                        leftHandBone.getWorldPosition(handPos);
                        vfxFront.position.copy(handPos);
                        vfxFront.quaternion.copy(model.quaternion);
                    }
                    for (let i = magicBalls.length - 1; i >= 0; i--) {
                        magicBalls[i].mesh.position.add(magicBalls[i].dir.clone().multiplyScalar(0.4));
                        if (magicBalls[i].life-- <= 0) { scene.remove(magicBalls[i].mesh); magicBalls.splice(i, 1); }
                    }

                    if (isJumping) {
                        model.position.y += velocityY; velocityY -= 0.008;
                        if (model.position.y <= 0) { model.position.y = 0; isJumping = false; canJump = true; fadeToAction('jump_land', 0.1); }
                    } else { model.position.y += ((isCrouching ? -0.4 : 0) - model.position.y) * 0.1; }

                    const dist = 5;
                    camera.position.set(model.position.x + dist * Math.sin(cameraAzimuth) * Math.cos(cameraElevation), model.position.y + 1.8 + dist * Math.sin(cameraElevation), model.position.z + dist * Math.cos(cameraAzimuth) * Math.cos(cameraElevation));
                    camera.lookAt(model.position.x, model.position.y + 1.2, model.position.z);
                }
                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
