<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>新しいタブ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #gui-overlay { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
            text-align: center; pointer-events: none; z-index: 200;
        }
        #ui-bar { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 300; }
        .item-slot {
            width: 60px; height: 60px; background: rgba(255, 255, 255, 0.1); border: 2px solid #555;
            display: flex; align-items: center; justify-content: center; color: white; font-size: 10px;
        }
        .item-slot.selected { border-color: #00aaff; background: rgba(0, 170, 255, 0.2); }
    </style>
</head>
<body>
    <div id="gui-overlay">CLICK TO START</div>
    <div id="ui-bar">
        <div class="item-slot selected">1</div>
        <div class="item-slot">2</div>
        <div class="item-slot">Special</div>
    </div>

    <script>
        let scene, camera, renderer, clock, mainMixer, coreModel;
        let vfxMixers = []; // 全エフェクトのミキサーを管理
        let keys = { q: false, e: false, c: false, s: false };
        let vertVel = 0, inAir = false, jumpReady = true, procActive = false, isLowPos = false;
        let activeIdx = 1, motionLib = {}, activeMotion;
        let l_mount, r_mount, subAsset, baseVfx, handVfx, projectiles = [];
        let camRotX = 0, camRotY = 0.2, isStandby = false;
        const gltfLoader = new THREE.GLTFLoader();

        function switchMotion(id, gap = 0.2) {
            const target = motionLib[id];
            if (target && activeMotion !== target) {
                if (activeMotion) activeMotion.fadeOut(gap);
                target.reset().fadeIn(gap).play();
                activeMotion = target;
            }
        }

        // ミキサー作成とアニメーション再生の共通関数
        function setupVfxAnimation(gltf, sceneObj) {
            if (gltf.animations && gltf.animations.length > 0) {
                const mixer = new THREE.AnimationMixer(sceneObj);
                gltf.animations.forEach(clip => mixer.clipAction(clip).play());
                vfxMixers.push(mixer);
                return mixer;
            }
            return null;
        }

        async function updateMode(idx) {
            if (activeIdx === idx || procActive) return;
            if (activeIdx === 3) {
                isStandby = false;
                if (baseVfx) baseVfx.visible = false;
                if (handVfx) handVfx.visible = false;
                switchMotion('m_end', 0.2);
                await new Promise(r => setTimeout(r, 400));
            }
            activeIdx = idx;
            document.querySelectorAll('.item-slot').forEach((s, i) => s.classList.toggle('selected', i === idx - 1));
            if (subAsset) subAsset.visible = (idx === 2);
            
            if (idx === 3) {
                isStandby = true;
                switchMotion('m_start', 0.2);
                if (baseVfx) { baseVfx.visible = true; baseVfx.position.y = -1.0; }
                if (handVfx) { handVfx.visible = true; handVfx.scale.set(0.11, 0.11, 0.11); }
                setTimeout(() => { if (activeIdx === 3) isStandby = false; }, 5000);
            } else { refreshMove(); }
        }

        function emitObj() {
            if (!l_mount) return;
            const pos = new THREE.Vector3();
            l_mount.getWorldPosition(pos);
            const offset = new THREE.Vector3(0, 0, 0.5).applyQuaternion(coreModel.quaternion);
            pos.add(offset);

            gltfLoader.load('./magicball.glb', (data) => {
                const obj = data.scene;
                obj.position.copy(pos);
                scene.add(obj);
                // 弾丸のアニメーションも再生
                const mixer = setupVfxAnimation(data, obj);
                projectiles.push({ mesh: obj, v: new THREE.Vector3(0, 0, 1).applyQuaternion(coreModel.quaternion), ttl: 120, mixer: mixer });
            });
        }

        function triggerAction() {
            if (procActive || inAir || isStandby) return;
            procActive = true;
            let mId = (activeIdx === 2) ? 'm_action2' : (activeIdx === 3 ? 'm_action3' : 'm_action1');
            if (activeIdx === 3) emitObj();
            switchMotion(mId, 0.1);
            setTimeout(() => { procActive = false; refreshMove(); }, 800);
        }

        function refreshMove() {
            if (procActive || inAir || activeIdx === 3) return;
            let dx = (keys.q ? -1 : 0) + (keys.c ? 1 : 0), dz = (keys.e ? -1 : 0) + (keys.s ? 1 : 0);
            if (dx !== 0 || dz !== 0) {
                if (isLowPos) switchMotion('m_low_walk', 0.2);
                else switchMotion((keys.e && !keys.s) ? 'm_fast' : 'm_walk', 0.2);
            } else {
                switchMotion(activeIdx === 2 ? 'm_idle2' : (isLowPos ? 'm_low_idle' : 'm_idle1'), 0.2);
            }
        }

        window.onload = function() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(5, 10, 5);
            scene.add(sun);

            gltfLoader.load('./magic.glb', (d) => { baseVfx = d.scene; baseVfx.visible = false; scene.add(baseVfx); setupVfxAnimation(d, baseVfx); });
            gltfLoader.load('./magic2.glb', (d) => { handVfx = d.scene; handVfx.visible = false; scene.add(handVfx); setupVfxAnimation(d, handVfx); });

            gltfLoader.load('./m.glb', (d) => {
                coreModel = d.scene; scene.add(coreModel);
                mainMixer = new THREE.AnimationMixer(coreModel);
                coreModel.traverse(n => {
                    if(n.isBone) {
                        const nm = n.name.toLowerCase();
                        if(nm.includes("hand") && nm.includes("l")) l_mount = n;
                        if(nm.includes("hand") && nm.includes("r")) r_mount = n;
                    }
                });

                gltfLoader.load('./sword.glb', (sd) => { subAsset = sd.scene; subAsset.visible = false; if(r_mount) r_mount.add(subAsset); });

                ['./a.glb', './b.glb'].forEach(u => {
                    gltfLoader.load(u, (ad) => {
                        ad.animations.forEach((clip, i) => {
                            const act = mainMixer.clipAction(clip);
                            if (clip.name === 'Idle_Loop') motionLib['m_idle1'] = act;
                            if (clip.name === 'Walk_Loop') motionLib['m_walk'] = act;
                            if (clip.name === 'Sprint_Loop') motionLib['m_fast'] = act;
                            if (clip.name === 'Jump_Start') { motionLib['m_j_s'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            if (clip.name === 'Jump_Loop') motionLib['m_j_l'] = act;
                            if (clip.name === 'Jump_Land') { motionLib['m_j_e'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            if (u === './b.glb') {
                                if (i === 1) motionLib['m_low_walk'] = act;
                                if (i === 2) motionLib['m_low_idle'] = act;
                                if (i === 25) { motionLib['m_action1'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 42) motionLib['m_idle2'] = act;
                                if (i === 40) { motionLib['m_action2'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 33) { motionLib['m_start'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 36) { motionLib['m_action3'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                                if (i === 34) { motionLib['m_end'] = act; act.setLoop(THREE.LoopOnce); act.clampWhenFinished = true; }
                            }
                        });
                        if (motionLib['m_idle1']) switchMotion('m_idle1');
                    });
                });
            });

            window.onkeydown = (e) => {
                const k = e.key.toLowerCase();
                if (['e','s','q','c'].includes(k)) keys[k] = true;
                if (k === 'v') isLowPos = !isLowPos;
                if (k === ' ' && !inAir && jumpReady && activeIdx !== 3) { inAir = true; jumpReady = false; vertVel = 0.18; switchMotion('m_j_s', 0.1); }
                if (['1','2','3'].includes(k)) updateMode(parseInt(k));
            };
            window.onkeyup = (e) => { if (['e','s','q','c'].includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; };
            window.addEventListener('mousemove', (e) => { if (document.pointerLockElement === document.body) { camRotX -= e.movementX * 0.002; camRotY = Math.max(-0.7, Math.min(1.1, camRotY + e.movementY * 0.002)); } });
            document.body.addEventListener('mousedown', () => { if(document.pointerLockElement !== document.body) { document.body.requestPointerLock(); document.getElementById('gui-overlay').style.display = 'none'; } else triggerAction(); });

            function animate() {
                requestAnimationFrame(animate);
                const dt = clock.getDelta();
                if (mainMixer) mainMixer.update(dt);
                vfxMixers.forEach(m => m.update(dt)); // すべてのエフェクトミキサーを更新

                if (coreModel) {
                    if (!procActive && activeIdx !== 3) {
                        let dx = (keys.q ? -1 : 0) + (keys.c ? 1 : 0), dz = (keys.e ? -1 : 0) + (keys.s ? 1 : 0);
                        if (dx !== 0 || dz !== 0) {
                            const target = Math.atan2(dx, dz) + camRotX;
                            let diff = target - coreModel.rotation.y;
                            while (diff < -Math.PI) diff += Math.PI * 2;
                            while (diff > Math.PI) diff -= Math.PI * 2;
                            coreModel.rotation.y += diff * 0.15;
                            const s = (keys.e && !keys.s && !isLowPos) ? 0.14 : 0.07;
                            coreModel.position.x += Math.sin(coreModel.rotation.y) * s;
                            coreModel.position.z += Math.cos(coreModel.rotation.y) * s;
                        }
                    }
                    refreshMove();

                    if (baseVfx && baseVfx.visible) {
                        baseVfx.position.set(coreModel.position.x, baseVfx.position.y, coreModel.position.z);
                        if (baseVfx.position.y < 0) baseVfx.position.y += 0.01;
                    }
                    if (handVfx && handVfx.visible && l_mount) {
                        const p = new THREE.Vector3(); l_mount.getWorldPosition(p);
                        const offset = new THREE.Vector3(0, 0, 0.3).applyQuaternion(coreModel.quaternion);
                        handVfx.position.copy(p).add(offset);
                        handVfx.rotation.y = coreModel.rotation.y;
                        handVfx.rotation.x = Math.PI / 2; // 垂直に立てる
                    }
                    for (let i = projectiles.length - 1; i >= 0; i--) {
                        projectiles[i].mesh.position.add(projectiles[i].v.clone().multiplyScalar(0.4));
                        if (projectiles[i].ttl-- <= 0) { scene.remove(projectiles[i].mesh); projectiles.splice(i, 1); }
                    }

                    if (inAir) {
                        coreModel.position.y += vertVel; vertVel -= 0.008;
                        if (coreModel.position.y <= 0) { coreModel.position.y = 0; inAir = false; setTimeout(() => { jumpReady = true; refreshMove(); }, 300); }
                    } else {
                        coreModel.position.y += ((isLowPos && activeIdx !== 3 ? -0.4 : 0) - coreModel.position.y) * 0.1;
                    }

                    const d = 2.4, hd = d * Math.cos(camRotY), vd = d * Math.sin(camRotY);
                    camera.position.set(coreModel.position.x + hd * Math.sin(camRotX), coreModel.position.y + 1.5 + vd, coreModel.position.z + hd * Math.cos(camRotX));
                    camera.lookAt(coreModel.position.x, coreModel.position.y + 1.2, coreModel.position.z);
                }
                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
